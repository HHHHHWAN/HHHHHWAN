
```
Q. Node.js는 왜 `latin1` 방식으로 인코딩하게 되었는지.
```

---
네, 아주 좋은 질문입니다. 왜 하필 `latin1` 이라는, 우리에게는 생소한 방식으로 Node.js가 해석을 시도하는지 궁금해하시는 것은 당연합니다.

결론부터 말씀드리면, **Node.js가 `latin1`을 특별히 선호해서가 아니라, 웹의 가장 근간이 되는 HTTP 프로토콜의 오래된 표준(Standard)을 충실히 따르기 때문**입니다.

자세히 설명해 드리겠습니다.

### 1. 웹의 역사: HTTP/1.1 표준의 탄생

문제의 근원은 웹 서버와 브라우저가 통신하는 규칙인 **HTTP/1.1 명세(RFC 2616)**에서 시작됩니다.

-   인터넷 초창기에 정의된 이 표준은, HTTP 헤더(Header)에 포함되는 텍스트는 **`ISO-8859-1`** 문자 집합을 사용해야 한다고 규정했습니다.
-   `ISO-8859-1`은 서유럽 언어들을 표현하기 위한 1바이트 문자 집합인데, 이것이 바로 **`latin1`**과 사실상 동일합니다.
-   이 당시에는 전 세계의 다양한 언어를 헤더에 담는 것을 심각하게 고려하지 않았고, 영문 중심의 표준이 만들어졌습니다.

따라서 Node.js의 저수준(low-level) HTTP 파서는 **"HTTP 헤더는 기본적으로 latin1일 것이다"** 라는 대전제 하에 설계되었습니다.

### 2. 브라우저와 서버의 인코딩 불일치

이제 한글 파일 "**한글.txt**" 를 업로드하는 상황을 단계별로 보겠습니다.

1.  **브라우저 (Client):** 브라우저는 `multipart/form-data` 요청을 보냅니다. 이때 파일 이름 "한글.txt"를 **UTF-8** 형식의 바이트(Byte) 배열로 변환하여 `Content-Disposition` 헤더에 담아 전송합니다.
    -   `한글` (UTF-8 Bytes) → `ed 95 9c ea b8 80`

2.  **Node.js 서버 (Server):** Node.js의 HTTP 파서는 이 요청을 받습니다. 그리고 오래된 표준에 따라, 헤더에 담긴 `ed 95 9c ea b8 80` 라는 바이트 배열을 **`latin1`**으로 해석하려고 시도합니다.
    -   `latin1`은 1바이트 문자 체계이므로, 각 바이트(`ed`, `95`, `9c` ...)를 하나의 문자로 인식합니다.
    -   그 결과, `file.originalname` 에는 `í•œê¸€` 같은 의미 없는 깨진 문자열이 할당됩니다.

### 3. `Buffer.from(..., 'latin1').toString('utf8')` 트릭의 원리

이것이 바로 이전 답변에서 알려드린 "마법 같은" 코드 한 줄이 동작하는 원리입니다.

-   **`Buffer.from(file.originalname, 'latin1')`**:
    -   Node.js에게 이렇게 말하는 것과 같습니다. "여기 `í•œê¸€` 라는 깨진 문자열이 있는데, **이게 원래 `latin1` 규칙으로 만들어진 결과물이야.**"
    -   Node.js는 이 말을 듣고 `í•œê¸€` 문자열을 다시 원래의 바이트 배열인 **`ed 95 9c ea b8 80`** 으로 복원합니다. (잘못된 해석 과정을 거꾸로 되돌리는 것입니다.)

    ![Image](https://github.com/user-attachments/assets/9b76c0b3-8c24-46cb-9435-e75d33b84102)

-   **`.toString('utf8')`**:
    -   이제 올바르게 복원된 바이트 배열 `ed 95 9c ea b8 80`을 가지고 Node.js에게 다시 말합니다. "**이 바이트 배열을 이번에는 `UTF-8` 규칙으로 해석해 줘.**"
    -   Node.js는 이 바이트들을 UTF-8 규칙에 따라 조합하여 마침내 우리가 원했던 "**한글**"이라는 원래의 문자열을 얻어냅니다.

    ![Image](https://github.com/user-attachments/assets/f65d0bc5-b0c8-4bfb-8319-1e0ad00621cb)

### 요약

| 구분 | 설명 |
| :--- | :--- |
| **원인** | Node.js의 저수준 HTTP 파서는 오래된 **HTTP/1.1 표준**을 따라, 헤더를 `latin1`으로 해석하려는 경향이 있습니다. |
| **현상** | 브라우저는 파일 이름을 **UTF-8** 바이트로 보내지만, 서버가 이를 **`latin1`**으로 잘못 읽어 글자가 깨집니다. |
| **해결** | 잘못 해석된(`latin1`) 문자열을 다시 원래의 바이트로 되돌린 후, 올바른(`UTF-8`) 방식으로 재해석하여 문제를 해결합니다. |

물론 최신 웹 표준(RFC 5987)에서는 `filename*`처럼 `*`을 붙이고 `UTF-8`을 명시하는 방식으로 이 문제를 개선했지만, 여전히 수많은 클라이언트와 서버 환경의 호환성을 위해 Node.js의 기본 동작은 과거의 표준을 따르고 있습니다. 그래서 `multer`와 같은 라이브러리를 사용할 때 이 `latin1` 트릭이 여전히 유효하고 강력한 해결책으로 사용되는 것입니다.
